generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserStatus {
  ACTIVE
  INACTIVE
  DELETED
  SUBSTITUTE
}

model User {
  id               String             @id @default(cuid())
  email            String             @unique
  name             String
  role             Role               @default(PLAYER)
  status           UserStatus         @default(ACTIVE)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  password         String
  language         String             @default("es")
  timezone         String             @default("GMT-5")
  assignedLineupId String?
  discordId        String?
  nationality      String?
  phone            String?
  realName         String?
  changeLogs       ChangeLog[]
  comments         Comment[]
  evaluationsGiven PlayerEvaluation[]
  playerProfile    PlayerProfile?
  assignedLineup   Lineup?            @relation("StaffLineup", fields: [assignedLineupId], references: [id])
  eventAttendances EventAttendance[]
  createdPlaybooks Playbook[]         @relation("PlaybookCreator")
}

model ChangeLog {
  id         String   @id @default(cuid())
  userId     String
  action     String
  entityType String
  entityId   String
  details    String?
  createdAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id])
}

model PlayerProfile {
  id                  String             @id @default(cuid())
  userId              String             @unique
  position            Position
  secondaryPosition   Position?
  communicationLevel  Int?
  personality         String?
  opggUrl             String?
  lineupId            String?
  phone               String?
  riotId              String?
  championPool        ChampionPool[]
  matchParticipations MatchParticipant[]
  evaluations         PlayerEvaluation[]
  lineup              Lineup?            @relation(fields: [lineupId], references: [id])
  user                User               @relation(fields: [userId], references: [id])
}

model Lineup {
  id          String          @id @default(cuid())
  name        String
  description String?
  isActive    Boolean         @default(true)
  scheduleLink String?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  matches     Match[]
  players     PlayerProfile[]
  staff       User[]          @relation("StaffLineup")
  events      ScheduleEvent[]
  tierLists   TierList[]
  draftPlans  DraftPlan[]
  configurations LineupConfiguration[]
  playbooks   Playbook[]
}

model PlayerEvaluation {
  id              String        @id @default(cuid())
  playerProfileId String
  coachId         String
  date            DateTime      @default(now())
  communication   Int
  mental          Int
  mechanics       Int
  gameKnowledge   Int
  teamplay        Int
  notes           String?
  improvementGoal String?
  strengths       String?
  weaknesses      String?
  coach           User          @relation(fields: [coachId], references: [id])
  playerProfile   PlayerProfile @relation(fields: [playerProfileId], references: [id])
}

model ChampionPool {
  id              String        @id @default(cuid())
  playerProfileId String
  championName    String
  mastery         MasteryLevel
  notes           String?
  playerProfile   PlayerProfile @relation(fields: [playerProfileId], references: [id])
}

model Team {
  id             String  @id @default(cuid())
  name           String
  isRival        Boolean @default(false)
  isVisible      Boolean @default(true)
  notes          String?
  opggUrl        String?
  matchesAsEnemy Match[] @relation("EnemyTeam")
  draftPlans     DraftPlan[]
  players        EnemyPlayer[]
  manualBans     EnemyBan[]
  tierLists      TierList[]
}

model EnemyPlayer {
  id        String   @id @default(cuid())
  teamId    String
  name      String   // Riot ID or Nickname
  role      Position
  opggUrl   String?
  notes     String?
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

model EnemyBan {
  id           String   @id @default(cuid())
  teamId       String
  championName String
  count        Int      @default(1)
  notes        String?
  team         Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
}


model Patch {
  id        String    @id @default(cuid())
  version   String    @unique
  startDate DateTime
  endDate   DateTime?
  matches   Match[]
}

model Match {
  id           String             @id @default(cuid())
  type         MatchType
  date         DateTime
  duration     Int?
  result       MatchResult?
  vodLink      String?
  patchId      String?
  enemyTeamId  String?
  ourSide      Side?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  blueBans     String[]
  redBans      String[]
  gameVersion  String?
  draftImageUrl String?
  lineupId     String?
  comments     Comment[]
  enemyTeam    Team?              @relation("EnemyTeam", fields: [enemyTeamId], references: [id])
  lineup       Lineup?            @relation(fields: [lineupId], references: [id])
  patch        Patch?             @relation(fields: [patchId], references: [id])
  analysis     MatchAnalysis?
  participants MatchParticipant[]
}

model MatchAnalysis {
  id           String  @id @default(cuid())
  matchId      String  @unique
  spawnNotes   String?
  earlyNotes   String?
  midNotes     String?
  lateNotes    String?
  winCondition String?
  keyMistakes  String?
  match        Match   @relation(fields: [matchId], references: [id])
}

model MatchParticipant {
  id                  String          @id @default(cuid())
  matchId             String
  playerProfileId     String?
  summonerName        String?
  championName        String
  position            Position
  kills               Int?
  deaths              Int?
  assists             Int?
  cs                  Int?
  gold                Int?
  damageDealt         Int?
  isEnemy             Boolean         @default(false)
  laneOpponent        String?
  matchupScore        Int?
  championRole        ChampionRole?
  communicationRating Float?
  laneAllocation      LaneAllocation?
  laningRating        Float?
  macroRating         Float?
  matchupNotes        String?
  mentalRating        Float?
  microRating         Float?
  positioningRating   Float?
  teamfightRating     Float?
  visionWards         Int             @default(0)
  wardsPlaced         Int             @default(0)
  match               Match           @relation(fields: [matchId], references: [id])
  playerProfile       PlayerProfile?  @relation(fields: [playerProfileId], references: [id])
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  createdAt DateTime @default(now())
  userId    String
  matchId   String?
  match     Match?   @relation(fields: [matchId], references: [id])
  user      User     @relation(fields: [userId], references: [id])
}

model Composition {
  id           String   @id @default(cuid())
  name         String
  description  String?
  winCondition String?
  difficulty   Int?
  topChamp     String?
  jungleChamp  String?
  midChamp     String?
  adcChamp     String?
  supportChamp String?
  tags         String[]
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

enum EventType {
  SCRIM
  TOURNAMENT
  TRAINING
  ACTIVITY_LOG
}

enum ScrimType {
  WARMUP
  EVALUATION
  SCRIM
}

enum EventModality {
  BO1
  BO2
  BO3
  BO5
  TWO_MAPS
  THREE_MAPS
  FIVE_MAPS
}

model ScheduleEvent {
  id          String    @id @default(cuid())
  title       String
  description String?
  startTime   DateTime
  endTime     DateTime?
  
  type        EventType
  
  // Scrim/Tournament specific fields
  opponentName    String?
  opponentContact String?
  scrimType       ScrimType?
  modality        EventModality?
  
  // Training specific fields
  activityType    String? // "Master Class", "VOD Review", etc.
  
  lineupId    String
  lineup      Lineup    @relation(fields: [lineupId], references: [id])
  
  attendances EventAttendance[]
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

enum AttendanceStatus {
  PRESENT
  ABSENT
  LATE
  EXCUSED
  PENDING
}

model EventAttendance {
  id        String           @id @default(cuid())
  eventId   String
  userId    String
  status    AttendanceStatus @default(PENDING)
  notes     String?
  
  event     ScheduleEvent    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user      User             @relation(fields: [userId], references: [id])
  
  @@unique([eventId, userId])
}

enum Role {
  ADMIN
  COACH
  PLAYER
  STAFF
}

enum Position {
  TOP
  JUNGLE
  MID
  ADC
  SUPPORT
}

enum LaneAllocation {
  STRONG_SIDE
  WEAK_SIDE
  NEUTRAL
  ROAMING
}

enum ChampionRole {
  ENGAGE
  PICKUP
  PROTECT
  SIEGE
  SPLITPUSH
}

enum MasteryLevel {
  MAIN
  POCKET
  LEARNING
}

enum MatchType {
  SCRIM
  SOLOQ
  TOURNAMENT
  SCOUTING
}

model TierList {
  id          String             @id @default(cuid())
  name        String
  description String?
  isActive    Boolean            @default(false)
  lineupId    String?
  enemyTeamId String?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  champions   TierListChampion[]
  lineup      Lineup?            @relation(fields: [lineupId], references: [id])
  enemyTeam   Team?              @relation(fields: [enemyTeamId], references: [id])
  draftPlansAsAlly  DraftPlan[] @relation("AllyTierList")
  draftPlansAsEnemy DraftPlan[] @relation("EnemyTierList")
}

model TierListChampion {
  id           String    @id @default(cuid())
  tierListId   String
  championName String
  tier         String
  role         Position?
  notes        String?
  tierList     TierList  @relation(fields: [tierListId], references: [id], onDelete: Cascade)
}

model DraftPlan {
  id          String   @id @default(cuid())
  name        String
  enemyTeamId String?
  lineupId    String?
  gameVersion String?
  ourSide     Side     @default(BLUE)
  blueBans    String[]
  redBans     String[]
  bluePicks   String[]
  redPicks    String[]
  notes       String?
  allyTierListId  String?
  enemyTierListId String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  enemyTeam   Team?    @relation(fields: [enemyTeamId], references: [id])
  lineup      Lineup?  @relation(fields: [lineupId], references: [id])
  allyTierList    TierList? @relation("AllyTierList", fields: [allyTierListId], references: [id])
  enemyTierList   TierList? @relation("EnemyTierList", fields: [enemyTierListId], references: [id])
}

enum MatchResult {
  WIN
  LOSS
  REMAKE
}

enum Side {
  BLUE
  RED
}

model LineupConfiguration {
  id          String   @id @default(cuid())
  name        String
  lineupId    String?
  assignments Json
  filters     Json
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  lineup      Lineup?  @relation(fields: [lineupId], references: [id])
}

// --- STRATEGY MODULE ---

model Playbook {
  id          String   @id @default(cuid())
  title       String
  description String?
  lineupId    String?
  creatorId   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  lineup      Lineup?  @relation(fields: [lineupId], references: [id])
  creator     User?    @relation("PlaybookCreator", fields: [creatorId], references: [id])
  scenes      StrategyScene[]
}

model StrategyScene {
  id          String   @id @default(cuid())
  playbookId  String
  title       String
  description String?
  imageUrl    String?
  order       Int      @default(0)
  
  // Recursive relation for Scene Tree (Parent -> Children)
  parentId    String?
  parent      StrategyScene?  @relation("SceneTree", fields: [parentId], references: [id], onDelete: Cascade)
  children    StrategyScene[] @relation("SceneTree")
  
  playbook    Playbook @relation(fields: [playbookId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
